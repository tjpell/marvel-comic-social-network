---
title: "Homework_3"
author: "Danai Avgerinou, Holly Capell, Shannon McNish, Taylor Pellerin, Kaya Tollas"
date: "4/22/2018"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(tidyverse)
library(igraph)
library(Matrix)
library(statnet)
library(knitr)
```


# Marvel Social Network dataset
```{r}
el <- read_csv("./data/hero-network.csv")
el = as.matrix(el)
marvel <- graph.edgelist(el,directed=FALSE)

wel <- read_csv("./data/weighted_edges.csv")
```

(a) What do the vertices and edges represent in this example?

Here, the nodes represent superheroes and edges represent them coexisting in a comic book together. In the raw df, there may be duplicate edges. In the weighted df, there are no duplicates.

(b) How many vertices and edges are there in the data set? 
```{r, echo = TRUE}

#Count the total number of nodes
vcount(marvel)

#Count the total number of edges
ecount(marvel)

dim(wel)
```
There are 574,467 total edges, including duplicates, 167,100 weighted deduplicated edges, and 6,421 nodes in this data set

(c) Is the network weighted? If so, what do the weights represent? 

Yes, the node weights represent the number of comic books that each character appeared in. The edge weights represent the number of times that each character appeared in a comic book together.

(d) Is the network directed or undirected? 

This network is undirected, since sharing space in a comic book is mutual.

(e1) How much storage will it require to store the network using sparse representation? 

Using a sparse representation, we only need to store the edges and their weights, and which heroes are involved. Each edge in this edge list takes 2 heros and one weight. There are 167,100 weighted edges and so we only need to store 501,300 observations. 

(e2) How about as an adjacency matrix?

In a weighted adjacency matrix, we would have to store (1/2)(n^2) - n weights where n =  6,206, the number of heros. This is because we have an undirected graph, so we only need the upper triangular quadrant of the matrix. We can also ignore the main diagonal, since we do not care if a character has self references. This comes out to 20,640,312 data points. If we also store the node weights here, we can put these on the "main diagonal"" of the adjacency matrix, leaving us with a total of  (1/2)(n^2), or 20,646,738 entries to keep track of.

(f) What kinds of questions would you like to investigate for this application?

(g) Extract 3 induced subgraphs, each with 200 random nodes, from the dataset that you've looked at
in (2). Visualize each of these networks using circular, Kamad-Kawai and Fructerman Reingold
layouts (total of 9 plots). Consider what attributes in your chosen network could be used to
recolor or resize the vertices. Are there any interesting network properties that become apparent
when coloring or resizing the vertices?

```{r}
wel <- read.csv("./data/weighted_edge_top_1000.csv") 
wel <- subset(wel, select = c("hero1", "hero2", "weight"))
g <- graph.data.frame(wel, directed = F)
```


```{r}

#import the sample_attributes
a <- read.csv("./data/weighted_nodes_top_1000.csv")

a$logged_weight <- log(a$weight)
labels <-  c(1,2,3,4)
a$weight_grp = cut(a$logged_weight, 4, include.lowest=TRUE, labels = labels)


V(g)$node_value <- as.numeric(a$weight_grp[match(V(g)$name,a$hero)]) 

V(g)$color=V(g)$node_value

V(g)$color=gsub("1","coral",V(g)$color) 
V(g)$color=gsub("2","firebrick1",V(g)$color) 
V(g)$color=gsub("3","firebrick3",V(g)$color) 
V(g)$color=gsub("4","darkred",V(g)$color) 

```

```{r}
g1 <- induced.subgraph(g, sample(V(g), 200))
g2 <- induced.subgraph(g, sample(V(g), 200))
g3 <- induced.subgraph(g, sample(V(g), 200))
```


```{r}
par(mfrow=c(1,3))
plot(g1, layout=layout.circle, edge.width=E(g1)$weight/50, vertex.label=NA, vertex.size=7)
plot(g1, layout=layout_with_fr(g1), edge.width=E(g1)$weight/50, vertex.label=NA, vertex.size=7)
plot(g1, layout=layout_with_kk(g1), edge.width=E(g1)$weight/50, vertex.label=NA, vertex.size=7)
```

```{r}
par(mfrow=c(1,3))
plot(g2, layout=layout.circle, edge.width=E(g1)$weight/50, vertex.label=NA, vertex.size=7)
plot(g2, layout=layout_with_fr(g1), edge.width=E(g1)$weight/50, vertex.label=NA, vertex.size=7)
plot(g2, layout=layout_with_kk(g1), edge.width=E(g1)$weight/50, vertex.label=NA, vertex.size=7)
```


```{r}
par(mfrow=c(1,3))
plot(g3, layout=layout.circle, edge.width=E(g1)$weight/50, vertex.label=NA, vertex.size=7)
plot(g3, layout=layout_with_fr(g1), edge.width=E(g1)$weight/50, vertex.label=NA, vertex.size=7)
plot(g3, layout=layout_with_kk(g1), edge.width=E(g1)$weight/50, vertex.label=NA, vertex.size=7)
```


(h) Run an exploratory analysis of the graph following along the visualizations, summary statistics,
and community detection work shown in the Network Descriptions.Rmd file on Canvas. Use these
techniques to answer the questions you posed in problem (1).

```{r, echo = TRUE}
# Checking whether or not the network is connected
igraph::is.connected(marvel)
```
The network is not connected.

```{r, echo = TRUE}
# decompose the graph into its connected components
comps <- decompose.graph(marvel) #calculates the connected components

#count the number of vertices in each connected component
table(sapply(comps, vcount)) 
```
The network has one large connected component and 3 smaller ones.


```{r, echo = TRUE}
d.marvel <- igraph::degree(marvel)  # this is the degree sequence

summary(d.marvel)  # get the distribution of the degrees

d.marvel.small <- d.marvel[d.marvel<200]  # clip outliers

#plot 
hist(d.marvel.small,col="blue", breaks = 75,
     xlab="Degree", ylab="Frequency",
     main="Degree Distribution")
```

There are some very connected heros, with the node with Captain America having the max degree of 16,499 connections. The distribution with outliers clipped shows the degrees peak around degree 10. 


```{r}
# get network diameter - max of shortest path distances excluding infinite paths

diameter(marvel)

```

This shows us that the maximum Marvel Number (for our main connected component) is 5, meaning that someone knows someone who knows someone ... who knows Ant Man.


### Convert Network Edge Data
```{r, echo = TRUE, eval = TRUE}
# create igraph from edgelist
el <- read_csv("./data/hero-network.csv")
marvel.edgelist = as.matrix(el)

marvel.igraph <- graph.edgelist(marvel.edgelist, directed=FALSE)
# adjacency matrix from igraph
marvel.adjacency <- as_adj(marvel.igraph)
```


```{r, echo = TRUE, eval = TRUE}
# create statnet object from edgelist
marvel.network <- network(marvel.edgelist)

# plot(marvel.network, main = paste(""), usearrows = TRUE, edge.col = "grey50")#, vertex.col = pblog.labels)
```


##Network Centrality Measures and Visualization

###Calculate In-Degree, Out-Degree, Eigenvector, Betweenness, and Closeness Centralities
```{r, echo = TRUE, eval = TRUE}
#in degree centrality
in.degree.centrality <- colSums(as.matrix(marvel.adjacency))

#out degree centrality
out.degree.centrality <- rowSums(as.matrix(marvel.adjacency))

#eigenvector centrality
eigenvector.centrality <- eigen_centrality(marvel.igraph, directed = FALSE)$vector

#normalized betweenness centrality
betweenness.centrality <- estimate_betweenness(marvel.igraph, directed = TRUE, cutoff = 10)

#closeness centrality
closeness.centrality <- estimate_closeness(marvel.igraph, mode = "total", normalized = FALSE, cutoff = 10)
```

```{r}
# These are all matrices...

# in.degree.centrality
# out.degree.centrality
# eigenvector.centrality
# betweenness.centrality
# closeness.centrality
```

###Plot Network According to Centrality Measures.

```{r, echo = TRUE}

# #plot in-degree
# plot(marvel.network, main = paste("In-Degree Centrality"), usearrows = TRUE, vertex.cex = in.degree.centrality / 50, edge.col = "grey50")
# 
# #plot out-degree
# plot(marvel.network, main = paste("Out-Degree Centrality"), usearrows = TRUE, vertex.cex = out.degree.centrality / 50, edge.col = "grey50", coord = sub.pblog.x, vertex.col = sub.labels)
# 
# #plot eigenvector
# plot(marvel.network, main = paste("Eigenvector Centrality"), usearrows = TRUE, vertex.cex = eigenvector.centrality*4 + 1, edge.col = "grey50", coord = sub.pblog.x, vertex.col = sub.labels)
# 
# #plot betweenness
# plot(marvel.network, main = paste("Betweenness Centrality"), usearrows = TRUE, vertex.cex = betweenness.centrality / 15000, edge.col = "grey50", coord = sub.pblog.x, vertex.col = sub.labels)
# 
# #plot closeness
# plot(marvel.network, main = paste("Closeness Centrality"), usearrows = TRUE, vertex.cex = closeness.centrality * 150 + 1, edge.col = "grey50", coord = sub.pblog.x, vertex.col = sub.labels)
```


### Check out Ego network
```{r}
##################################

#An ego network is nothing but the neighborhood of a given "ego" / node

#Ego network of the main instructor (node 1)
#ego <- induced.subgraph(marvel, igraph::neighborhood(marvel, 1, 'BLACK WIDOW/NATASHA')[[1]])

#get degrees of nodes
deg <- igraph::degree(marvel)
dSorted <- sort.int(deg,decreasing = T, index.return = F)

topDegreeNames <- dSorted[1:20]
```


```{r}
degreetop20bet <- subset(betweenness.centrality, names(betweenness.centrality) %in% topDegreeNames)
degreetop20bet

degreetop20Eigen <- subset(eigenvector.centrality, names(eigenvector.centrality) %in% topDegreeNames)
degreetop20Eigen
```

## Which heros are central to the network and how does that compare to the number of connections

```{r}
#get degrees of nodes
deg <- igraph::degree(marvel.igraph)
dSorted <- sort.int(deg,decreasing = T, index.return = F)

#get top 20 nodes with most degrees
topDegree <- dSorted[1:20]
topDegreeNames <- names(topDegree)

t1 <- data.frame(Hero=names(topDegree), Degrees=topDegree, row.names=NULL)
kable(t1, caption= "Top 20 Heros by Number of Degrees")
```

Calculate eigenvector and betweenness centralities:
```{r, echo = TRUE, eval = TRUE}
#eigenvector centrality
eigenvector.centrality <- eigen_centrality(marvel.igraph, directed = FALSE)$vector
eSorted <- sort.int(eigenvector.centrality,decreasing = T, index.return = F)[1:20]

#normalized betweenness centrality
betweenness.centrality <- estimate_betweenness(marvel.igraph, directed = TRUE, cutoff = 10)
bSorted <- sort.int(betweenness.centrality,decreasing = T, index.return = F)[1:20]
```

Look at betweenness and eigenvector centrailty of those in top 20 by degree
```{r}

degreetop20bet <- subset(betweenness.centrality, names(betweenness.centrality) %in% topDegreeNames)
degreetop20bet

degreetop20Eigen <- subset(eigenvector.centrality, names(eigenvector.centrality) %in% topDegreeNames)
degreetop20Eigen 
```

```{r}
t2 <- data.frame(Hero=names(bSorted), Betweeness=bSorted, row.names=NULL)
kable(t2, caption= "Top 20 Heros by Betweeness Centrality")

```

```{r}
t3 <- data.frame(Hero=names(eSorted), Eigenvector=eSorted, row.names=NULL)
kable(t3, caption= "Top 20 Heros by Eigenvector Centrality")

```


PLOTS
```{r}
# Betweenness Centrality

bSorted <- sort.int(betweenness.centrality,decreasing = T, index.return = F)

topBetweenNames <- bSorted[1:20]
top20 <- names(topBetweenNames)

# Create list of top 100 heros
top100 <- bSorted[1:100]
top100 <- names(top100)

# Create attribute of whether or not hero is in our top 20
a2 <- as.matrix(a$hero)
a2 <- replace(a2, a2 %in% top20, 4)
a2 <- replace(a2, !(a2 %in% top20) & a2 != 4, 2)

df <- data.frame(a$hero, a2)

# Create subgraph of top 100 heroes

top_100 <- a$hero %in% top100
g_small <- induced.subgraph(g, V(g)[top_100])

g.edgelist <- as_edgelist(g_small)
small.network <- network(g.edgelist, directed = F)
plot(small.network, vertex.col = a2, edge.col = "grey50")



```



```{r}
# Degree

dSorted <- sort.int(deg,decreasing = T, index.return = F)

topDegreeNames <- dSorted[1:20]
top20 <- names(topDegreeNames)

# Create list of top 100 heros
top100 <- dSorted[1:100]
top100 <- names(top100)

# Create attribute of whether or not hero is in our top 20
a2 <- as.matrix(a$hero)
a2 <- replace(a2, a2 %in% top20, 4)
a2 <- replace(a2, !(a2 %in% top20) & a2 != 4, 2)

df <- data.frame(a$hero, a2)

# Create subgraph of top 100 heroes

top_100 <- a$hero %in% top100
g_small <- induced.subgraph(g, V(g)[top_100])

g.edgelist <- as_edgelist(g_small)
small.network <- network(g.edgelist, directed = F)
plot(small.network, vertex.col = a2, edge.col = "grey50")
```


```{r}
# Eigenvector Centrality

eSorted <- sort.int(eigenvector.centrality,decreasing = T, index.return = F)

topEigNames <- eSorted[1:20]
top20 <- names(topEigNames)

# Create list of top 100 heros
top100 <- eSorted[1:100]
top100 <- names(top100)

# Create attribute of whether or not hero is in our top 20
a2 <- as.matrix(a$hero)
a2 <- replace(a2, a2 %in% top20, 4)
a2 <- replace(a2, !(a2 %in% top20) & a2 != 4, 2)

df <- data.frame(a$hero, a2)

# Create subgraph of top 100 heroes

top_100 <- a$hero %in% top100
g_small <- induced.subgraph(g, V(g)[top_100])

g.edgelist <- as_edgelist(g_small)
small.network <- network(g.edgelist, directed = F)
plot(small.network, vertex.col = a2, edge.col = "grey50")


```

