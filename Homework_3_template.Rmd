---
title: "Homework_3"
author: "Danai Avgerinou, Holly Capell, Shannon McNish, Taylor Pellerin, Kaya Tollas"
date: "4/22/2018"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library(tidyverse)
library(igraph)
library(Matrix)
library(statnet)
```

# 1. Iris dataset

## Graph 1: points whose distances are within the lowest 25% 

To produce this graph, distances between flower observations using all features were calcuated. An edge is present between two observations if the distance is within the shortest 25% of all distances calcuated. 

### (a)
```{r 1a}
data(iris)

# seperate data
irisData <- iris[,1:4]
irisClass <- as.numeric(iris$Species)

# standardize data to have mean 0
irisData <- scale(irisData)

# Calculate adjacency matrix of distances between all pairs of flowers
adjacency.mat <- as.matrix(dist(irisData))

# get 25 percentile of distances
quart25 <- quantile(adjacency.mat[lower.tri(adjacency.mat,diag=FALSE)],.25)

# remove edges not in the bottom 25% distances
adjacency.mat1 <- ifelse((adjacency.mat<=quart25) & (adjacency.mat>0), 1, 0)

#visulize adjacency matrix
image(Matrix(adjacency.mat1))
```

### (b)
```{r 1b}
# turn adjacency matrix to igraph object
graph1 <- graph.adjacency(adjacency.mat1,mode='undirected')

# specify a vector of 3 colors for the speciies
colorvec <- c('yellow','magenta','lightblue')

# assign colors to nodes
V(graph1)$color <- colorvec[irisClass]

# plot data
plot(graph1,vertex.size=6,vertex.label=NA)
legend("bottomleft", legend=c('setosa','versicolor','virginica') , col = colorvec , bty = "n", 
       pch=20 , pt.cex = 3, cex = 1 , horiz = FALSE)
```

### (c) 

We decided the circle graph was the best layout to visualize the community structure since it was the only one that clearly indicated that setosa only linked within its species whereas versicolor and virginica linked to each other and themselves. 

```{r 1c}
plot(graph1, layout = layout.circle, vertex.label=NA, vertex.size=6)
legend("bottomleft", legend=c('setosa','versicolor','virginica') , col = colorvec , bty = "n", 
       pch=20 , pt.cex = 3, cex = 1 , horiz = FALSE)
# plot(graph, layout = layout.fruchterman.reingold, vertex.label=NA, vertex.size=6)
# plot(graph, layout = layout.kamada.kawai, vertex.label=NA, vertex.size=6)
```

## Graph 2: points whose distances are within the lowest 40% 

To produce this graph, distances between flower observations using all features were calcuated. An edge is present between two observations if the distance is within the shortest 40% of all distances calcuated. 

### (a)
```{r 1.2.a}
# get 40th percentile of distances
quart40 <- quantile(adjacency.mat[lower.tri(adjacency.mat,diag=FALSE)],.4)

# remove edges not in the bottom 25% distances
adjacency.mat2 <- ifelse((adjacency.mat<=quart40) & (adjacency.mat>0), 1, 0)

#visulize adjacency matrix
image(Matrix(adjacency.mat2))
```

### (b)
```{r 1b.2}
# turn adjacency matrix to igraph object
graph2 <- graph.adjacency(adjacency.mat2,mode='undirected')

# specify a vector of 3 colors for the speciies
colorvec <- c('yellow','magenta','lightblue')

# assign colors to nodes
V(graph2)$color <- colorvec[irisClass]

# plot data
plot(graph2,vertex.size=6,vertex.label=NA)
legend("bottomleft", legend=c('setosa','versicolor','virginica') , col = colorvec , bty = "n", 
       pch=20 , pt.cex = 3, cex = 1 , horiz = FALSE)
```
### (c) 

For this graph, we decided the Kamada Kawai layout was best in this case to show the linkages between setosa and versicolor. This layout makes it clear how many linkages there are between these two species. 

```{r 1c.2}
#plot(graph2, layout = layout.circle, vertex.label=NA, vertex.size=6)
#plot(graph2, layout = layout.fruchterman.reingold, vertex.label=NA, vertex.size=6)
plot(graph2, layout = layout.kamada.kawai, vertex.label=NA, vertex.size=6)
legend("bottomleft", legend=c('setosa','versicolor','virginica') , col = colorvec , bty = "n", 
       pch=20 , pt.cex = 3, cex = 1 , horiz = FALSE)
```


### (d) Comparision of the two networks

This analysis compares the above two networks: Graph 1 has an edge present if the flower observations are within the lowest 25% pecent of distances calculated using all features, and Graph 2 uses the same methodology except the threshold is higher at 40%.

```{r 1d.1}
igraph::is.connected(graph1)
```

```{r 1d.11}
igraph::is.connected(graph2)
```

Graph 1 is not fully connected, whereas if the threshold is relaxed, the graph becomes fully connected.

```{r 1d.3}
# decompose graph1 into its connected components
comps1 <- decompose.graph(graph1) #calculates the connected components

#count the number of vertices in each connected component
table(sapply(comps1, vcount)) 
```
Graph 1 has a large component of 100 nodes, a smaller component of 49 nodes, and one observation not connected to anything. 

```{r 1d.2}
# get network diameter
diameter(graph1)
diameter(graph2)
```
Both graphs have a diameter of 6, which is the max of shortest path distances excluding infinite paths.


```{r 1d.4}
#Count the total number of edges in graph 1
ecount(graph1)
```

```{r 1d.41}
#Count the total number of edges in graph 2
ecount(graph2)

```
Both graphs have 150 nodes, but graph 2 (the one with a 40% distance threshold of edges) has almost double the amount of edges graph 1 has. 

```{r}
#Calculate the degree of the  network
d.g1 <- igraph::degree(graph1) #this is the degree sequence
hist(d.g1 ,col="blue",
     xlab="Degree", ylab="Frequency",
     main="Degree Distribution - Graph 1")

#Calculate the degree of the  network
d.g2 <- igraph::degree(graph2) #this is the degree sequence
hist(d.g2 ,col="blue",
     xlab="Degree", ylab="Frequency",
     main="Degree Distribution - Graph 2")
```

The degree of a node in a network is the number of connections it has to other nodes. Both graphs have a peak of nodes with around 50 degrees, but graph 2 has an additional peak of nodes with around 80 degrees.


# 2. Marvel Social Network dataset
```{r}
el <- read_csv("./data/hero-network.csv")
el = as.matrix(el)
marvel <- graph.edgelist(el,directed=FALSE)

wel <- read_csv("./data/weighted_edges.csv")
```

(a) What do the vertices and edges represent in this example?
Here, the nodes represent superheroes and edges represent them coexisting in a comic book together. In the raw df, there may be duplicate edges. In the weighted df, there are no duplicates.

(b) How many vertices and edges are there in the data set? 
```{r, echo = TRUE}

#Count the total number of nodes
vcount(marvel)

#Count the total number of edges
ecount(marvel)

dim(wel)
```
There are 574,467 total edges, including duplicates, 167,100 weighted deduplicated edges, and 6,421 nodes in this data set

(c) Is the network weighted? If so, what do the weights represent? 
Yes, the node weights represent the number of comic books that each character appeared in. The edge weights represent the number of times that each character appeared in a comic book together.

(d) Is the network directed or undirected? 
This network is undirected, since sharing space in a comic book is mutual.

(e1) How much storage will it require to store the network using sparse representation? 

Using a sparse representation, we only need to store the edges and their weights, and which heroes are involved. Each edge in this edge list takes 2 heros and one weight. There are 167,100 weighted edges and so we only need to store 501,300 observations. 

(e2) How about as an adjacency matrix?

In a weighted adjacency matrix, we would have to store (1/2)(n^2) - n weights where n =  6,206, the number of heros. This is because we have an undirected graph, so we only need the upper triangular quadrant of the matrix. We can also ignore the main diagonal, since we do not care if a character has self references. This comes out to 20,640,312 data points. If we also store the node weights here, we can put these on the "main diagonal"" of the adjacency matrix, leaving us with a total of  (1/2)(n^2), or 20,646,738 entries to keep track of.

(f) What kinds of questions would you like to investigate for this application?
------


(g) Extract 3 induced subgraphs, each with 200 random nodes, from the dataset that you've looked at
in (2). Visualize each of these networks using circular, Kamad-Kawai and Fructerman Reingold
layouts (total of 9 plots). Consider what attributes in your chosen network could be used to
recolor or resize the vertices. Are there any interesting network properties that become apparent
when coloring or resizing the vertices?

```{r}
wel <- read.csv("./data/weighted_edge_top_1000.csv") 
wel <- subset(wel, select = c("hero1", "hero2", "weight"))
g <- graph.data.frame(wel, directed = F)
```


```{r}

#import the sample_attributes
a <- read.csv("./data/weighted_nodes_top_1000.csv")

a$logged_weight <- log(a$weight)
labels <-  c(1,2,3,4)
a$weight_grp = cut(a$logged_weight, 4, include.lowest=TRUE, labels = labels)


V(g)$node_value <- as.numeric(a$weight_grp[match(V(g)$name,a$hero)]) 

V(g)$color=V(g)$node_value

V(g)$color=gsub("1","coral",V(g)$color) 
V(g)$color=gsub("2","firebrick1",V(g)$color) 
V(g)$color=gsub("3","firebrick3",V(g)$color) 
V(g)$color=gsub("4","darkred",V(g)$color) 

```

```{r}
g1 <- induced.subgraph(g, sample(V(g), 200))
g2 <- induced.subgraph(g, sample(V(g), 200))
g3 <- induced.subgraph(g, sample(V(g), 200))
```


```{r}
par(mfrow=c(1,3))
plot(g1, layout=layout.circle, edge.width=E(g1)$weight/50, vertex.label=NA, vertex.size=7)
plot(g1, layout=layout_with_fr(g1), edge.width=E(g1)$weight/50, vertex.label=NA, vertex.size=7)
plot(g1, layout=layout_with_kk(g1), edge.width=E(g1)$weight/50, vertex.label=NA, vertex.size=7)
```

```{r}
par(mfrow=c(1,3))
plot(g2, layout=layout.circle, edge.width=E(g1)$weight/50, vertex.label=NA, vertex.size=7)
plot(g2, layout=layout_with_fr(g1), edge.width=E(g1)$weight/50, vertex.label=NA, vertex.size=7)
plot(g2, layout=layout_with_kk(g1), edge.width=E(g1)$weight/50, vertex.label=NA, vertex.size=7)
```


```{r}
par(mfrow=c(1,3))
plot(g3, layout=layout.circle, edge.width=E(g1)$weight/50, vertex.label=NA, vertex.size=7)
plot(g3, layout=layout_with_fr(g1), edge.width=E(g1)$weight/50, vertex.label=NA, vertex.size=7)
plot(g3, layout=layout_with_kk(g1), edge.width=E(g1)$weight/50, vertex.label=NA, vertex.size=7)
```


(h) Run an exploratory analysis of the graph following along the visualizations, summary statistics,
and community detection work shown in the Network Descriptions.Rmd file on Canvas. Use these
techniques to answer the questions you posed in problem (1).

```{r, echo = TRUE}
# Checking whether or not the network is connected
igraph::is.connected(marvel)
```
The network is not connected.

```{r, echo = TRUE}
# decompose the graph into its connected components
comps <- decompose.graph(marvel) #calculates the connected components

#count the number of vertices in each connected component
table(sapply(comps, vcount)) 
```
The network has one large connected component and 3 smaller ones.


```{r, echo = TRUE}
d.marvel <- igraph::degree(marvel)  # this is the degree sequence

summary(d.marvel)  # get the distribution of the degrees

d.marvel.small <- d.marvel[d.marvel<200]  # clip outliers


#plot 
hist(d.marvel.small,col="blue", breaks = 75,
     xlab="Degree", ylab="Frequency",
     main="Degree Distribution")
```

There are some very connected heros, with the node with Captain America having the max degree of 16,499 connections. The distribution with outliers clipped shows the degrees peak around degree 10. 


```{r}
# get network diameter - max of shortest path distances excluding infinite paths

diameter(marvel)

```

This shows us that the maximum Marvel Number (for our main connected component) is 5, meaning that someone knows someone who knows someone ... who knows Ant Man.


### Convert Network Edge Data
```{r, echo = TRUE, eval = TRUE}
# create igraph from edgelist
el <- read_csv("./data/hero-network.csv")
marvel.edgelist = as.matrix(el)

marvel.igraph <- graph.edgelist(marvel.edgelist, directed=FALSE)
# adjacency matrix from igraph
marvel.adjacency <- as_adj(marvel.igraph)
```


```{r, echo = TRUE, eval = TRUE}
# create statnet object from edgelist
marvel.network <- network(marvel.edgelist)

plot(marvel.network, main = paste(""), usearrows = TRUE, edge.col = "grey50")#, vertex.col = pblog.labels)
```


##Network Centrality Measures and Visualization

###Calculate In-Degree, Out-Degree, Eigenvector, Betweenness, and Closeness Centralities
```{r, echo = TRUE, eval = TRUE}
#in degree centrality
in.degree.centrality <- colSums(as.matrix(marvel.adjacency))

#out degree centrality
out.degree.centrality <- rowSums(as.matrix(marvel.adjacency))

#eigenvector centrality
eigenvector.centrality <- eigen_centrality(marvel.igraph, directed = FALSE)$vector

#normalized betweenness centrality
betweenness.centrality <- estimate_betweenness(marvel.igraph, directed = TRUE, cutoff = 10)

#closeness centrality
closeness.centrality <- estimate_closeness(marvel.igraph, mode = "total", normalized = FALSE, cutoff = 10)
```

```{r}
# These are all matrices...

# in.degree.centrality
# out.degree.centrality
# eigenvector.centrality
# betweenness.centrality
# closeness.centrality
```

###Plot Network According to Centrality Measures.

# need to update the labels, but I think holly did this part earlier

```{r, echo = TRUE}

#plot in-degree
plot(marvel.network, main = paste("In-Degree Centrality"), usearrows = TRUE, vertex.cex = in.degree.centrality / 50, edge.col = "grey50")

#plot out-degree
plot(marvel.network, main = paste("Out-Degree Centrality"), usearrows = TRUE, vertex.cex = out.degree.centrality / 50, edge.col = "grey50", coord = sub.pblog.x, vertex.col = sub.labels)

#plot eigenvector
plot(marvel.network, main = paste("Eigenvector Centrality"), usearrows = TRUE, vertex.cex = eigenvector.centrality*4 + 1, edge.col = "grey50", coord = sub.pblog.x, vertex.col = sub.labels)

#plot betweenness
plot(marvel.network, main = paste("Betweenness Centrality"), usearrows = TRUE, vertex.cex = betweenness.centrality / 15000, edge.col = "grey50", coord = sub.pblog.x, vertex.col = sub.labels)

#plot closeness
plot(marvel.network, main = paste("Closeness Centrality"), usearrows = TRUE, vertex.cex = closeness.centrality * 150 + 1, edge.col = "grey50", coord = sub.pblog.x, vertex.col = sub.labels)
```


### Check out Ego network
```{r}
##################################

#An ego network is nothing but the neighborhood of a given "ego" / node

#Ego network of the main instructor (node 1)
#ego <- induced.subgraph(marvel, igraph::neighborhood(marvel, 1, 'BLACK WIDOW/NATASHA')[[1]])

#get degrees of nodes
deg <- igraph::degree(marvel)
dSorted <- sort.int(deg,decreasing = T, index.return = F)

topDegreeNames <- dSorted[1:20]
```


```{r}
degreetop20bet <- subset(betweenness.centrality, names(betweenness.centrality) %in% topDegreeNames)
degreetop20bet

degreetop20Eigen <- subset(eigenvector.centrality, names(eigenvector.centrality) %in% topDegreeNames)
degreetop20Eigen
```

## Which heros are central to the network and how does that compare to the number of connections

```{r}
#get degrees of nodes
deg <- igraph::degree(marvel.igraph)
dSorted <- sort.int(deg,decreasing = T, index.return = F)

#get top 20 nodes with most degrees
topDegree <- dSorted[1:20]
topDegreeNames <- names(topDegree)

t1 <- data.frame(Hero=names(topDegree), Degrees=topDegree, row.names=NULL)
kable(t1, caption= "Top 20 Heros by Number of Degrees")
```

Calculate eigenvector and betweenness centralities:
```{r, echo = TRUE, eval = TRUE}
#eigenvector centrality
eigenvector.centrality <- eigen_centrality(marvel.igraph, directed = FALSE)$vector
eSorted <- sort.int(eigenvector.centrality,decreasing = T, index.return = F)[1:20]

#normalized betweenness centrality
betweenness.centrality <- estimate_betweenness(marvel.igraph, directed = TRUE, cutoff = 10)
bSorted <- sort.int(betweenness.centrality,decreasing = T, index.return = F)[1:20]
```

Look at betweenness and eigenvector centrailty of those in top 20 by degree
```{r}

degreetop20bet <- subset(betweenness.centrality, names(betweenness.centrality) %in% topDegreeNames)
degreetop20bet

degreetop20Eigen <- subset(eigenvector.centrality, names(eigenvector.centrality) %in% topDegreeNames)
degreetop20Eigen 
```

```{r}
t2 <- data.frame(Hero=names(bSorted), Betweeness=bSorted, row.names=NULL)
kable(t2, caption= "Top 20 Heros by Betweeness Centrality")

```

```{r}
t3 <- data.frame(Hero=names(eSorted), Eigenvector=eSorted, row.names=NULL)
kable(t3, caption= "Top 20 Heros by Eigenvector Centrality")

```


PLOTS
```{r}
# Betweenness Centrality

bSorted <- sort.int(betweenness.centrality,decreasing = T, index.return = F)

topBetweenNames <- bSorted[1:20]
top20 <- names(topBetweenNames)

# Create list of top 100 heros
top100 <- bSorted[1:100]
top100 <- names(top100)

# Create attribute of whether or not hero is in our top 20
a2 <- as.matrix(a$hero)
a2 <- replace(a2, a2 %in% top20, 4)
a2 <- replace(a2, !(a2 %in% top20) & a2 != 4, 2)

df <- data.frame(a$hero, a2)

# Create subgraph of top 100 heroes

top_100 <- a$hero %in% top100
g_small <- induced.subgraph(g, V(g)[top_100])

g.edgelist <- as_edgelist(g_small)
small.network <- network(g.edgelist, directed = F)
plot(small.network, vertex.col = a2, edge.col = "grey50")



```



```{r}
# Degree

dSorted <- sort.int(deg,decreasing = T, index.return = F)

topDegreeNames <- dSorted[1:20]
top20 <- names(topDegreeNames)

# Create list of top 100 heros
top100 <- dSorted[1:100]
top100 <- names(top100)

# Create attribute of whether or not hero is in our top 20
a2 <- as.matrix(a$hero)
a2 <- replace(a2, a2 %in% top20, 4)
a2 <- replace(a2, !(a2 %in% top20) & a2 != 4, 2)

df <- data.frame(a$hero, a2)

# Create subgraph of top 100 heroes

top_100 <- a$hero %in% top100
g_small <- induced.subgraph(g, V(g)[top_100])

g.edgelist <- as_edgelist(g_small)
small.network <- network(g.edgelist, directed = F)
plot(small.network, vertex.col = a2, edge.col = "grey50")
```


```{r}
# Eigenvector Centrality

eSorted <- sort.int(eigenvector.centrality,decreasing = T, index.return = F)

topEigNames <- eSorted[1:20]
top20 <- names(topEigNames)

# Create list of top 100 heros
top100 <- eSorted[1:100]
top100 <- names(top100)

# Create attribute of whether or not hero is in our top 20
a2 <- as.matrix(a$hero)
a2 <- replace(a2, a2 %in% top20, 4)
a2 <- replace(a2, !(a2 %in% top20) & a2 != 4, 2)

df <- data.frame(a$hero, a2)

# Create subgraph of top 100 heroes

top_100 <- a$hero %in% top100
g_small <- induced.subgraph(g, V(g)[top_100])

g.edgelist <- as_edgelist(g_small)
small.network <- network(g.edgelist, directed = F)
plot(small.network, vertex.col = a2, edge.col = "grey50")


```

